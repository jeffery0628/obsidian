---
Create: 2022年 四月 10日, 星期日 17:04
tags: 
  - Engineering/scala
  - 大数据
---

# 算术运算符

| 运算符 | 运算       | 范例       | 结果    |
| ------ | ---------- | ---------- | ------- |
| +      | 正号       | +3         | 3       |
| -      | 负号       | b=4; -b    | -4      |
| +      | 加         | 5+5        | 10      |
| -      | 减         | 6-4        | 2       |
| *      | 乘         | 3\*4        | 12      |
| /      | 除         | 5/5        | 1       |
| %      | 取模(取余) | 7%5        | 2       |
| +      | 字符串相加 | “He”+”llo” | “Hello” |

> 注：
> 1. 对于除号“/”，它的整数除和小数除是有区别的：整数之间做除法时，只保留整数部分而舍弃小数部分。
> 2. 对一个数取模a%b，和Java的取模规则一样。

```scala
object TestArithmetic {

    def main(args: Array[String]): Unit = {

        //（1）对于除号“/”，它的整数除和小数除是有区别的：整数之间做除法时，只保留整数部分而舍弃小数部分。
        var r1: Int = 10 / 3 // 3
        var r2: Double = 10 / 3 // 3.0
        var r3: Double = 10.0 / 3 // 3.3333
        println("r3=" + r3.formatted("%.2f")) // 含义：保留小数点2位，使用四舍五入

        //（2）对一个数取模a%b，和Java的取模规则一样。
        var r4 = 10 % 3 // 1
    }
}
```

# 关系运算符

| 运算符 | 运算     | 范例  | 结果  |
| ------ | -------- | ----- | ----- |
| ==     | 相等于   | 4\=\=3  | false |
| !=     | 不等于   | 4！=3 | true  |
| <      | 小于     | 4<3   | false |
| >      | 大于     | 4>3   | true  |
| <=     | 小于等于 | 4<=3  | false |
| >=     | 大于等于 | 4>=3  | true  |

> Java和Scala中关于\==的区别
>
> Java：\==比较两个变量本身的值，即两个对象在内存中的首地址；equals比较字符串中所包含的内容是否相同。
>
> Scala：\==更加类似于Java中的equals。

java
```java
public static void main(String[] args) {
    
    String s1 = "abc";
    String s2 = new String("abc");

    System.out.println(s1 == s2);

    System.out.println(s1.equals(s2));
}
输出结果：
false
true
```

Scala
```scala
def main(args: Array[String]): Unit = {

    val s1 = "abc"

    val s2 = new String("abc")

    println(s1 == s2)
	println(s1.eq(s2))
}
输出结果：
true
false
```

# 逻辑运算符

假定：变量A为true，B为false

| 运算符 | 描述   | 实例                       |
| ------ | ------ | -------------------------- |
| &&     | 逻辑与 | (A && B) 运算结果为 false  |
| \|\|   | 逻辑或 | (A \|\| B) 运算结果为 true |
| !      | 逻辑非 | !(A && B) 运算结果为 true  |



# 赋值运算符

| 运算符 | 描述                                           | 实例                                  |
| ------ | ---------------------------------------------- | ------------------------------------- |
| =      | 简单的赋值运算符，将一个表达式的值赋给一个左值 | C = A + B 将 A + B 表达式结果赋值给 C |
| +=     | 相加后再赋值                                   | C += A 等于 C = C + A                 |
| -=     | 相减后再赋值                                   | C -= A 等于 C = C - A                 |
| \*=     | 相乘后再赋值                                   | C \*= A 等于 C = C * A                 |
| /=     | 相除后再赋值                                   | C /= A 等于 C = C / A                 |
| %=     | 求余后再赋值                                   | C %= A 等于 C = C % A                 |
| <<=    | 左移后赋值                                     | C <<= 2等于 C = C << 2                |
| >>=    | 右移后赋值                                     | C >>= 2 等于 C = C >> 2               |
| &=     | 按位与后赋值                                   | C &= 2  等于 C = C & 2                |
| ^=     | 按位异或后赋值                                 | C ^= 2  等于 C = C ^ 2                |
| \|=    | 按位或后赋值                                   | C \|= 2  等于 C = C \| 2              |

> Scala中没有++、--操作符，可以通过+=、-=来实现同样的效果；

# 位运算符

下表中变量 a 为 60，b 为 13。a:00111100,   b:00001101

| 运算符 | 描述           | 实例                                                         |
| ------ | -------------- | ------------------------------------------------------------ |
| &      | 按位与运算符   | (a & b) 输出结果 12 ，二进制解释： 0000 1100                 |
| \|     | 按位或运算符   | (a \| b) 输出结果 61 ，二进制解释： 0011 1101                |
| ^      | 按位异或运算符 | (a ^ b) 输出结果 49 ，二进制解释： 0011 0001                 |
| ~      | 按位取反运算符 | (~a ) 输出结果 -61 ，二进制解释： 1100 0011， 在一个有符号二进制数的补码形式。 |
| <<     | 左移动运算符   | a << 2 输出结果 240 ，二进制解释： 0011 0000                 |
| >>     | 右移动运算符   | a >> 2 输出结果 15 ，二进制解释： 0000 1111                  |
| >>>    | 无符号右移     | a >>>2 输出结果 15, 二进制解释: 0000 1111                    |



# 运算符本质

在Scala中其实是没有运算符的，所有运算符都是方法。

1. 当调用对象的方法时，点.可以省略
2. 如果函数参数只有一个，或者没有参数，()可以省略

```scala
object TestOpt {
    def main(args: Array[String]): Unit = {

        // 标准的加法运算
        val i:Int = 1.+(1)

        // （1）当调用对象的方法时，.可以省略
        val j:Int = 1 + (1)

        // （2）如果函数参数只有一个，或者没有参数，()可以省略
        val k:Int = 1 + 1
        
        println(1.toString())
        println(1 toString())
        println(1 toString)
    }
}
```



